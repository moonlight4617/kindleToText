# 2025-11-23

## 実施内容

環境検証スクリプト（validate_environment.py）の不具合診断と修正

### 目的・背景

Phase 8 で作成した環境検証スクリプト `scripts/validate_environment.py` を実行したところ、以下のテスト失敗が発生：

```
================================================================================
Validation Summary
================================================================================
Python Version            ✓ PASS
Required Packages         ✗ FAIL
Tesseract OCR             ✗ FAIL
Configuration File        ✗ FAIL
Output Directory          ✓ PASS
Kindle for PC             ✓ PASS
```

実際にはパッケージがインストールされているにもかかわらず、誤検出される問題があったため、原因を調査して修正を実施した。

### 所要時間／作業時間の見積もりと実績

- **見積もり**: 1時間
- **実績**: 約1時間
  - 問題の診断: 30分
  - 修正実装: 20分
  - 動作確認: 10分

## 発見された問題

### 問題1: パッケージインポート名の不一致

**現象**:
```
✗ Pillow not installed
✗ opencv-python not installed
✗ pyyaml not installed
✗ pywin32 not installed
```

**原因**:

Python パッケージの PyPI パッケージ名（pip install で使う名前）とインポート時のモジュール名が異なる場合がある。

| PyPI パッケージ名 | インポート名 |
|-----------------|------------|
| Pillow          | PIL        |
| opencv-python   | cv2        |
| pyyaml          | yaml       |
| pywin32         | win32api   |

元のコードは、パッケージ名をそのまま `__import__()` に渡していたため、インポートに失敗していた。

**元のコード**:
```python
def check_dependencies():
    """必須パッケージの確認"""
    logger.info("Checking required packages...")
    required_packages = [
        "click",
        "loguru",
        "Pillow",
        "numpy",
        "opencv-python",
        "pytesseract",
        "pyyaml",
        "pywin32",
    ]

    all_ok = True
    for package in required_packages:
        try:
            __import__(package.replace("-", "_").lower())  # ← 不適切な変換
            logger.success(f"✓ {package}")
        except ImportError:
            logger.error(f"✗ {package} not installed")
            all_ok = False

    return all_ok
```

### 問題2: Unicode エンコーディングエラー

**現象**:
```
UnicodeEncodeError: 'cp932' codec can't encode character '\u2713' in position 26: illegal multibyte sequence
```

**原因**:

Windows のデフォルトコンソールエンコーディングは cp932（Shift-JIS）であり、UTF-8 文字である ✓（U+2713）と ✗（U+2717）を表示できない。

スクリプトは loguru で直接これらの記号を出力していたため、Windows 環境でクラッシュしていた。

### 問題3: config.yaml が存在しない

**現象**:
```
✗ Configuration file not found: c:\Users\...\config\config.yaml
```

**原因**:

プロジェクトには `config.example.yaml` しか存在せず、実際の設定ファイル `config.yaml` が作成されていなかった。

## 修正内容

### 修正1: パッケージ名とインポート名のマッピング

**ファイル**: `scripts/validate_environment.py`

**変更箇所**: `check_dependencies()` 関数

```python
def check_dependencies():
    """必須パッケージの確認"""
    logger.info("Checking required packages...")
    # パッケージ名とインポート名のマッピング
    required_packages = {
        "click": "click",
        "loguru": "loguru",
        "Pillow": "PIL",
        "numpy": "numpy",
        "opencv-python": "cv2",
        "pytesseract": "pytesseract",
        "pyyaml": "yaml",
        "pywin32": "win32api",
    }

    all_ok = True
    for package_name, import_name in required_packages.items():
        try:
            __import__(import_name)
            logger.success(f"✓ {package_name}")
        except ImportError:
            logger.error(f"✗ {package_name} not installed")
            all_ok = False

    return all_ok
```

**変更内容**:
- リストから辞書に変更し、パッケージ名（表示用）とインポート名（実際のインポート用）を分離
- 各パッケージに対して正しいインポート名を明示的に指定

### 修正2: Windows コンソールの UTF-8 対応

**ファイル**: `scripts/validate_environment.py`

**変更箇所**: スクリプトの冒頭（import 直後）

```python
import sys
import io
from pathlib import Path

# Windows コンソールの文字エンコーディング問題を修正
if sys.platform == "win32":
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')
```

**変更内容**:
- Windows プラットフォーム検出時に、`sys.stdout` と `sys.stderr` を UTF-8 で再ラップ
- これにより、✓ や ✗ などの UTF-8 文字を Windows コンソールでも表示可能に

### 修正3: config.yaml の作成

**コマンド**:
```bash
cp config/config.example.yaml config/config.yaml
```

**実施内容**:
- `config.example.yaml` を `config.yaml` にコピー
- これで ConfigLoader が設定ファイルを読み込めるようになった

## テスト結果

### 修正前

```
================================================================================
Validation Summary
================================================================================
Python Version            ✓ PASS
Required Packages         ✗ FAIL
Tesseract OCR             ✗ FAIL
Configuration File        ✗ FAIL
Output Directory          ✓ PASS
Kindle for PC             ✓ PASS
```

### 修正後

```
Checking Python version...
✓ Python 3.11.5
Checking required packages...
✓ click
✓ loguru
✓ Pillow
✓ numpy
✓ opencv-python
✓ pytesseract
✓ pyyaml
✓ pywin32
Checking Tesseract OCR...
✗ Tesseract not found or not in PATH
Checking configuration file...
✓ Configuration file loaded: config\config.yaml
✓ Kindle settings found
✓ OCR settings found
  Primary OCR engine: yomitoku
Checking output directory...
✓ Output directory exists: output
✓ Output directory is writable
Checking Kindle for PC...
✓ Kindle for PC found: C:\Users\...\Kindle.exe

================================================================================
Validation Summary
================================================================================
Python Version            ✓ PASS
Required Packages         ✓ PASS
Tesseract OCR             ✗ FAIL
Configuration File        ✓ PASS
Output Directory          ✓ PASS
Kindle for PC             ✓ PASS
```

**結果**: Tesseract OCR を除く全ての検証がパスするようになった。

## Tesseract OCR の扱いについて

### 現状

Tesseract OCR は未インストールであり、検証スクリプトでは FAIL となっている。

### 方針決定

**一時的に Tesseract OCR は使用しない方向で進める**

**理由**:
1. プライマリOCRエンジンは `yomitoku` であり、Tesseract は補助的な位置づけ
2. Tesseract は pip でインストールできず、手動インストールが必要（ユーザーの手間）
3. 現時点での実機テストでは yomitoku のみで十分

**今後の対応**:
- 実機テストは yomitoku のみで実施
- 必要に応じて後から Tesseract を追加することは可能
- ドキュメントには「オプション」として Tesseract の情報を記載

## 課題・詰まった点と解決策

### 課題1: パッケージ名の調査

**課題**: どのパッケージがどのモジュール名でインポートされるか、一つ一つ確認する必要があった

**解決策**:
- よく知られているパッケージ（Pillow → PIL、opencv-python → cv2）は経験から判断
- pywin32 は複数のモジュールを含むが、代表的な `win32api` で確認

### 課題2: UTF-8 対応の方法

**課題**: Windows コンソールで UTF-8 を使う方法が複数存在

**解決策**:
- `chcp 65001` でコンソールを変更する方法もあるが、ユーザーに実行を要求することになる
- `sys.stdout` を UTF-8 でラップする方法が、スクリプト内で完結するため採用

## 使用したツール・技術要素のメモ

### Python の `__import__()` 関数

動的にモジュールをインポートするための組み込み関数。

```python
# 通常のインポート
import numpy

# 動的インポート（同等）
numpy = __import__("numpy")
```

パッケージ検証では、文字列からモジュールをインポートする必要があるため使用。

### `io.TextIOWrapper`

バイナリストリームをテキストストリームとしてラップするクラス。

```python
import sys
import io

# sys.stdout（通常は cp932）を UTF-8 で再ラップ
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
```

これにより、コンソールへの出力を UTF-8 エンコーディングで強制できる。

### loguru のカラー出力

loguru は自動的にターミナルを検出し、カラー出力を行う。

```python
logger.success("✓ Python 3.11.5")  # 緑色で表示
logger.error("✗ Package not found")  # 赤色で表示
```

UTF-8 対応により、Windows でも正しく表示されるようになった。

## 学び／気づき

### 1. Python パッケージ名の不一致は頻出問題

PyPI パッケージ名とインポート名が異なるケースは想像以上に多い。環境検証スクリプトを作成する際は、明示的なマッピングが必須。

**よくある例**:
- `beautifulsoup4` → `bs4`
- `Pillow` → `PIL`
- `opencv-python` → `cv2`
- `scikit-learn` → `sklearn`
- `pyyaml` → `yaml`

### 2. Windows 環境でのエンコーディング問題

Windows のコンソールエンコーディングは歴史的経緯で複雑。

- デフォルト: cp932（日本語版 Windows）
- PowerShell 7+: UTF-8 デフォルト
- cmd.exe: cp932 デフォルト

クロスプラットフォームのスクリプトでは、UTF-8 出力を明示的に設定することが重要。

### 3. 環境検証スクリプトの価値

今回の修正により、環境検証スクリプトが実際に動作するようになった。これにより：

- ユーザーは実機テスト前に環境の問題を発見できる
- トラブルシューティングが容易になる
- 「動かない」問題の原因切り分けが迅速化

環境検証スクリプトは、ツール配布時に非常に価値が高い。

### 4. 段階的なテスト実施の重要性

Phase 8 のインフラ整備時には自動テストは実施せず、ユーザーが実行して初めて問題が発覚した。

**教訓**:
- インフラスクリプトも、作成直後に動作確認すべき
- 特にクロスプラットフォーム対応の場合、実環境での確認が重要

## 次に実施する予定のタスク

### 短期

1. **Tesseract オプション化の検討**
   - config.yaml で Tesseract 使用を無効化できるようにする
   - または、検証スクリプトで Tesseract を「オプション」として警告のみ表示

2. **実機テストの実施**
   - `docs/MANUAL_TESTING.md` に従ってテスト実施
   - yomitoku エンジンのみで動作確認

### 長期

1. **Tesseract 対応の再検討**
   - yomitoku で精度が不十分な場合、Tesseract を追加
   - ハイブリッドモード（yomitoku + Tesseract フォールバック）の実装

2. **環境検証スクリプトの拡張**
   - GPU 対応チェック（CUDA、DirectML など）
   - メモリ容量チェック
   - ディスク空き容量チェック

## その他メモ

### 修正したファイル

- `scripts/validate_environment.py`: パッケージチェックと UTF-8 対応を修正
- `config/config.yaml`: `config.example.yaml` からコピー作成

### 検証コマンド

```bash
# 仮想環境の Python で実行
./venv/Scripts/python.exe scripts/validate_environment.py
```

### 成功時の出力例

```
================================================================================
Validation Summary
================================================================================
Python Version            ✓ PASS
Required Packages         ✓ PASS
Tesseract OCR             ✗ FAIL  ← 想定内（一時的に使用しない）
Configuration File        ✓ PASS
Output Directory          ✓ PASS
Kindle for PC             ✓ PASS
================================================================================
```

Tesseract 以外が全て PASS であれば、実機テストを開始できる状態。

---

## 実機テスト時の問題と修正

環境検証が完了し、実機テスト（基本動作テスト）を実施したところ、複数の問題が発見された。以下、発見された問題と修正内容を記録する。

### 問題4: TextWriter 初期化時の引数エラー

**現象**:
```
Failed to initialize workflow: TextWriter.__init__() got multiple values for argument 'encoding'
```

**原因**:

`main.py` で `TextWriter` を間違った方法で初期化していた。

```python
# ❌ 間違い（main.py:89-91）
self.text_writer = TextWriter(
    str(output_file), encoding=self.config["output"]["encoding"]
)
```

**問題点**:
- `TextWriter.__init__()` の第1引数は `encoding` であり、ファイルパスを受け取らない
- ファイルパスは `create_file()` や `append_text()` メソッドで指定する設計
- `str(output_file)` が位置引数として `encoding` に渡され、さらにキーワード引数 `encoding=...` も渡されるため、引数の重複エラーが発生

**TextWriter の正しいシグネチャ**:
```python
def __init__(
    self,
    encoding: str = "utf-8",        # 第1引数は encoding
    add_bom: bool = False,
    newline: Optional[str] = None
):
```

**修正内容**:

**ファイル**: `main.py:89-92`

```python
# 修正後
self.text_writer = TextWriter(
    encoding=self.config["output"]["encoding"]
)
self.output_file = output_file  # ファイルパスをインスタンス変数に保存
```

**ファイル**: `main.py:227-228`

```python
# 修正前
self.text_writer.append_text(text)
self.text_writer.append_text("\n" + "=" * 80 + "\n\n")

# 修正後（ファイルパスを第1引数に指定）
self.text_writer.append_text(self.output_file, text)
self.text_writer.append_text(self.output_file, "\n" + "=" * 80 + "\n\n")
```

**結果**: ワークフローの初期化が成功するようになった。

---

### 問題5: ページ送りの方向指定エラー

**現象**:
```
ERROR | src.capture.screenshot:turn_page - Invalid direction: Right
```

**原因**:

`turn_page()` メソッドは `direction` 引数として `"forward"` または `"backward"` を期待するが、`main.py` から `page_turn_key` の値（`"Right"`）を渡していた。

```python
# ❌ 間違い（main.py:232-234）
self.screenshot_capture.turn_page(
    self.config["kindle"]["page_turn_key"]  # "Right" を渡している
)
```

**turn_page() の定義**:
```python
def turn_page(self, direction: str = "forward") -> bool:
    """
    Args:
        direction: ページ送りの方向（"forward" or "backward"）
    """
    if direction == "forward":
        key = self.page_turn_key  # 内部で page_turn_key を使用
    elif direction == "backward":
        # 逆方向のキーを自動判定
        ...
    else:
        logger.error(f"Invalid direction: {direction}")
        return False
```

**修正内容**:

**ファイル**: `main.py:232`

```python
# 修正後
self.screenshot_capture.turn_page("forward")  # 方向のみを指定
```

**結果**: ページ送りコマンドが正しく実行されるようになった（ただし、次の問題により実際にはページが移動しない）。

---

### 問題6: ScreenshotCapture 初期化時の引数エラー

**現象**:
```
ERROR | src.capture.screenshot:turn_page - Failed to turn page: 'dict' object has no attribute 'lower'
```

**原因**:

`ScreenshotCapture` の初期化で設定辞書全体を渡していたため、`page_turn_key` に辞書が格納され、`key.lower()` を実行しようとして失敗した。

```python
# ❌ 間違い（main.py:76）
self.screenshot_capture = ScreenshotCapture(self.config)
```

**ScreenshotCapture の定義**:
```python
def __init__(
    self,
    page_turn_key: str = "right",      # 第1引数は文字列
    page_load_delay: float = 1.5,
    screenshot_delay: float = 0.5
):
```

**修正内容**:

**ファイル**: `main.py:76-80` および `main.py:143-147`（2箇所）

```python
# 修正後
self.screenshot_capture = ScreenshotCapture(
    page_turn_key=self.config["kindle"]["page_turn_key"],
    page_load_delay=self.config["kindle"]["page_turn_delay"],
    screenshot_delay=self.config["kindle"].get("window_activation_delay", 0.5)
)
```

**結果**: `page_turn_key` に文字列（`"Right"`）が正しく渡され、`key.lower()` が正常に動作するようになった。

---

### 問題7: pyautogui のキー名（大文字・小文字）

**現象**:

エラーは出ないが、実際にページが送られない。

**原因**:

`pyautogui.press()` は小文字のキー名（`'right'`, `'left'` など）を期待するが、設定ファイルでは大文字の `"Right"` が指定されていた。

**config.yaml**:
```yaml
page_turn_key: "Right"  # 大文字
```

**pyautogui の期待**:
```python
pyautogui.press('right')  # 小文字を期待
```

**修正内容**:

**ファイル**: `src/capture/screenshot.py:175`

```python
# 修正前
pyautogui.press(key)

# 修正後
pyautogui.press(key.lower())  # 小文字に変換
```

**結果**: 設定ファイルで `"Right"` でも `"right"` でも動作するようになった。

---

### 問題8: ウィンドウアクティブ化のエラー

**現象**:
```
ERROR | src.capture.window_manager:activate_window - Failed to activate window: Error code from Windows: 0 - この操作を正しく終了しました。
```

**原因**:

`target_window.activate()` が Windows のセキュリティ設定により例外を発生させる場合がある。エラーコード0は「成功」を意味するが、pygetwindow が例外をスローしていた。

**修正内容**:

**ファイル**: `src/capture/window_manager.py:122-137`

```python
# ウィンドウをアクティブ化
try:
    target_window.activate()
except Exception as activate_error:
    # activate() は Windows のセキュリティ設定により失敗する場合がある
    # その場合は win32gui を使用
    logger.debug(f"activate() failed, trying alternative method: {activate_error}")
    try:
        import win32gui
        import win32con
        hwnd = win32gui.FindWindow(None, window_info.title)
        if hwnd:
            win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
            win32gui.SetForegroundWindow(hwnd)
    except Exception as win32_error:
        logger.warning(f"Alternative activation also failed: {win32_error}")
        # 失敗しても続行（ウィンドウは既に見つかっている）

time.sleep(0.3)  # ウィンドウのアクティブ化を待つ
```

**改善点**:
- 2段階のフォールバック（`activate()` → `SetForegroundWindow()`）
- エラーの許容（両方失敗してもプロセスを続行）
- 詳細なデバッグログ

**結果**: ウィンドウアクティブ化のエラーが解消され、処理が継続するようになった。

---

### 問題9: ページ送り時にウィンドウがアクティブでない

**現象**:

エラーは出ないが、実際にページが移動しない。ログを見ると、OCR処理の後にページ送りコマンドが実行されているが、ページが変わっていない。

**原因**:

処理の流れ：
1. ウィンドウをアクティブ化（197行目）
2. スクリーンショット撮影
3. 画像前処理
4. **OCR処理（10秒以上かかる）** ← この間に他のウィンドウがアクティブになる可能性
5. テキスト保存
6. ページ送り（232行目） ← Kindleウィンドウがアクティブでない

OCR処理に時間がかかるため、その間にユーザーが他のウィンドウをクリックしたり、システムが他のウィンドウをアクティブにする可能性がある。その結果、ページ送りのキー入力がKindleウィンドウに届かない。

**修正内容**:

**ファイル**: `main.py:232-237`

```python
# 次のページへ
if page_number < self.state.total_pages:
    # ページ送り前にウィンドウを再アクティブ化
    self.window_manager.activate_window(window)
    self.screenshot_capture.turn_page("forward")
    self.screenshot_capture.wait_for_page_load(
        self.config["kindle"]["page_turn_delay"]
    )
```

**結果**: OCR処理の後でも確実にKindleウィンドウがアクティブな状態でページ送りが実行され、ページが正常に移動するようになった。

---

### 問題10: スクリーンショット番号が page_0002.png から始まる

**現象**:

最初のスクリーンショットが `page_0001.png` ではなく `page_0002.png` から始まる。

**原因**:

`create_initial_state()` で `current_page=start_page` としていたため、初期状態で `current_page=1` になっていた。その後、`run()` メソッドで `start_page = self.state.current_page + 1` とするため、`start_page = 2` となり、ページ2から始まっていた。

Phase 6 の設計では、`current_page` は「最後に処理したページ番号」を意味し、初期値は `start_page - 1` であるべきだった。

**修正内容**:

**ファイル**: `src/state/state_manager.py:253`

```python
# 修正前
state = StateData(
    ...
    current_page=start_page,
    ...
)

# 修正後
state = StateData(
    ...
    current_page=start_page - 1,  # 初期値は開始ページの1つ前（まだ処理していない）
    ...
)
```

**結果**: `start_page=1` の場合、初期状態で `current_page=0` となり、ページ1から処理が開始され、スクリーンショットが `page_0001.png` から始まるようになった。

---

### 問題11: スクリーンショットに無駄な余白がある（DPIスケーリング問題）

**現象**:

スクリーンショット画像（PNG）が非常に幅広で、無駄な余白が多い。

**調査結果**:

```bash
# スクリーンショットサイズを確認
Screenshot size: 2880x996

# DPIスケーリングを確認
DPI Scale Factor: 150
```

- システムのDPIスケーリング: **150%**（1.5倍）
- スクリーンショットサイズ: 2880 x 996 ピクセル
- 実際のウィンドウサイズ: 1920 x 664 論理ピクセル
- 2880 ÷ 1.5 = 1920（計算が一致）

**原因**:

Windows の高DPI環境では、座標系が混在する：

1. **論理ピクセル**: アプリケーションが認識する座標（DPI非依存）
2. **物理ピクセル**: 実際のスクリーン座標（DPIスケーリング適用後）

DPI Aware でないアプリケーションでは、この2つが混同され、座標がズレる。

- `win32gui.GetClientRect()` は論理ピクセルを返す
- `win32gui.ClientToScreen()` やスクリーンショットは物理ピクセルを使用
- 結果：座標のズレ、画像が幅広になる（1.5倍に拡大）

**修正内容**:

#### 修正11-1: DPI Aware の設定

**ファイル**: `main.py:10-19`

```python
import ctypes

# Windows DPI Aware を設定（高DPI環境での座標ズレを防ぐ）
try:
    ctypes.windll.shcore.SetProcessDpiAwareness(2)  # PROCESS_PER_MONITOR_DPI_AWARE
except Exception:
    try:
        ctypes.windll.user32.SetProcessDPIAware()  # Windows 8.1 以前のフォールバック
    except Exception:
        pass  # DPI Aware 設定に失敗しても続行
```

**効果**:
- アプリケーションが物理ピクセルで動作するようになる
- `win32gui` の API が正しい座標を返すようになる
- スクリーンショットとウィンドウ座標が一致する

**DPI Awareness のレベル**:
- `2` (PROCESS_PER_MONITOR_DPI_AWARE): 各モニターのDPIを認識（推奨）
- フォールバック: Windows 8.1 以前用の `SetProcessDPIAware()`

#### 修正11-2: クライアント領域の正確な取得

**ファイル**: `src/capture/window_manager.py:167-190`

**修正前**（座標変換が不正確）:
```python
client_rect = win32gui.GetClientRect(hwnd)
left, top = win32gui.ClientToScreen(hwnd, (client_rect[0], client_rect[1]))
right, bottom = win32gui.ClientToScreen(hwnd, (client_rect[2], client_rect[3]))
width = right - left
height = bottom - top
```

**修正後**（正確な座標とサイズ）:
```python
# ウィンドウ全体の矩形（スクリーン座標）
window_rect = win32gui.GetWindowRect(hwnd)
# クライアント領域の矩形（ウィンドウ座標、0,0 始まり）
client_rect = win32gui.GetClientRect(hwnd)

# クライアント領域の左上をスクリーン座標に変換
client_screen_pos = win32gui.ClientToScreen(hwnd, (0, 0))

# クライアント領域のサイズと位置
left = client_screen_pos[0]
top = client_screen_pos[1]
width = client_rect[2] - client_rect[0]   # クライアント領域の幅
height = client_rect[3] - client_rect[1]  # クライアント領域の高さ

region = Region(left=left, top=top, width=width, height=height)
logger.debug(f"Window rect: {window_rect}, Client rect: {client_rect}")
```

**改善点**:
1. **正しい基準点**: クライアント領域は常に (0,0) から始まるため、`ClientToScreen(hwnd, (0,0))` で左上の座標を取得
2. **正しいサイズ計算**: `GetClientRect` が返すのは (0, 0, width, height) なので、サイズは直接 `[2]-[0]` と `[3]-[1]` で計算
3. **デバッグログ追加**: ウィンドウ矩形とクライアント矩形を記録

**結果**:
- スクリーンショットのサイズが適切になった
- 無駄な余白が削減され、Kindleのコンテンツ部分のみが正確にキャプチャされる
- タイトルバー、ツールバー、メニューバーが除外される

---

## 修正の全体像

### 修正したファイルと箇所

1. **main.py**
   - DPI Aware 設定追加（10-19行目）
   - TextWriter 初期化修正（89-92行目）
   - ScreenshotCapture 初期化修正（76-80行目、143-147行目）
   - ページ送り方向指定修正（232行目）
   - ページ送り前のウィンドウ再アクティブ化（233行目）
   - テキスト保存時のファイルパス指定（227-228行目）

2. **src/state/state_manager.py**
   - 初期状態の current_page 修正（253行目）

3. **src/capture/screenshot.py**
   - キー名の小文字変換（175行目）

4. **src/capture/window_manager.py**
   - ウィンドウアクティブ化のエラーハンドリング（122-137行目）
   - クライアント領域取得の正確な実装（167-190行目）

### テスト結果

修正後、基本動作テストを再実行した結果：

- ✅ Yomitoku モデルの初期化成功
- ✅ Kindle ウィンドウの検出とアクティブ化成功
- ✅ スクリーンショットが `page_0001.png` から開始
- ✅ PNG画像のサイズが適切（余白が削減）
- ✅ ページ送りが正常に動作
- ✅ OCR処理が実行され、テキストが出力される

基本動作テストの主要な問題がすべて解決され、正常に動作するようになった。

---

## 学び／気づき（実機テスト編）

### 1. インターフェース設計の重要性

`TextWriter` や `ScreenshotCapture` の初期化で引数の渡し方を間違えた。これは：
- クラスのインターフェースが明確に文書化されていなかった
- テストが実際のワークフロー全体をカバーしていなかった
- 型ヒントがあっても実行時エラーは防げない

**教訓**: 統合テストの重要性。各モジュールの単体テストだけでなく、実際の使用方法をテストする統合テストが必要。

### 2. Windows プラットフォーム固有の問題

DPIスケーリング、ウィンドウアクティブ化のセキュリティ制限など、Windows 固有の問題が多数発生した。

**教訓**: プラットフォーム固有の動作は、実機でのテストでしか発見できない。特にGUI自動化では、OS のバージョンやセキュリティ設定によって動作が変わる。

### 3. 高DPI環境の複雑さ

DPIスケーリングの問題は、開発環境とユーザー環境が異なる場合に発生しやすい。

**対策**:
- アプリケーション起動時に DPI Aware を設定
- 論理ピクセルと物理ピクセルの違いを理解
- Win32 API を使用する場合は、座標系の違いに注意

### 4. エラーメッセージの誤解

「Error code: 0 - この操作を正しく終了しました」というエラーは、実際にはエラーではなく、ライブラリの例外処理の問題だった。

**教訓**: エラーメッセージを鵜呑みにせず、実際の動作を確認する。特にサードパーティライブラリの場合、エラーハンドリングが不適切な場合がある。

### 5. 段階的なデバッグの重要性

複数の問題が重なっていたが、1つずつ解決することで、根本原因を特定できた。

**手順**:
1. エラーログを確認
2. 該当箇所のコードを読む
3. 期待される動作と実際の動作を比較
4. 最小限の修正で問題を解決
5. 次の問題に進む

### 6. ウィンドウフォーカスの難しさ

OCR処理中にウィンドウのフォーカスが失われる問題は、ユーザーインターフェースの自動化で頻繁に発生する。

**対策**:
- 重要な操作の直前にウィンドウを再アクティブ化
- フォールバック機能の実装（複数の方法でアクティブ化を試行）
- 失敗しても致命的エラーとせず、可能な限り続行

---

## 次に実施する予定のタスク

### 短期

1. **基本動作テストの継続**
   - より多くのページでテスト（10ページ以上）
   - OCR精度の確認
   - パフォーマンスの測定

2. **手動テストガイドの他のシナリオ実施**
   - テスト2: 中断・再開機能
   - テスト3: エラーハンドリング
   - テスト4: パラメータ調整

3. **発見された問題の記録**
   - テスト結果を `TEST_RESULTS_TEMPLATE.md` に記録
   - 追加の問題があれば修正

### 中期

1. **Phase 8 完了記録**
   - 実機テスト完了後、dev_diary に Phase 8 完了を記録
   - implementation_plan.md を更新

2. **Phase 9: ドキュメント整備**
   - README.md の作成
   - INSTALLATION.md の作成
   - USAGE.md の作成
   - TROUBLESHOOTING.md の作成（今回の問題も含める）

---

## その他メモ

### 実機テストで修正したファイル一覧

```
project/
├── main.py                          # DPI設定、初期化修正、ページ送り修正
├── src/
│   ├── state/
│   │   └── state_manager.py        # current_page 初期値修正
│   ├── capture/
│   │   ├── screenshot.py           # キー名小文字変換
│   │   └── window_manager.py       # ウィンドウアクティブ化、領域取得修正
│   └── output/
│       └── text_writer.py          # 変更なし（使い方の修正のみ）
```

### 動作確認コマンド

```bash
# 環境検証
python scripts/validate_environment.py

# 基本動作テスト
python main.py --title "LLM自作入門" --total-pages 3 --debug

# 出力確認
ls output/LLM自作入門_screenshots/  # スクリーンショット確認
cat output/LLM自作入門.txt            # OCR結果確認
```

### 問題12: 初回スクリーンショットで間違ったウィンドウが撮影される

**日時**: 2025-11-25 23:32

**現象**:
2ページのOCR処理を実行したところ、以下の問題が発生：
- `page_0001.png`: VSCodeのウィンドウが撮影されている
- `page_0002.png`: 正しくKindleウィンドウが撮影されている

**調査結果**:

ログを詳細に分析した結果、以下のことが判明：

```
2025-11-25 23:32:29.503 | INFO | Processing page 1/2
2025-11-25 23:32:29.505 | INFO | Kindle window found: 田辺涼二さんの Kindle for PC2 - つくりながら学ぶ！LLM 自作入門
2025-11-25 23:32:29.507 | DEBUG | activate() failed, trying alternative method: Error code from Windows: 0
2025-11-25 23:32:29.533 | WARNING | Alternative activation also failed: (0, 'SetForegroundWindow', 'No error message is available')
2025-11-25 23:32:29.834 | INFO | Window activated successfully: 田辺涼二さんの Kindle for PC2
2025-11-25 23:32:30.404 | DEBUG | Screenshot captured: size=(1920, 1057)
```

**根本原因**:

`src/capture/window_manager.py` の `activate_window()` メソッドに重大な問題がある。

該当コード ([window_manager.py:122-142](src/capture/window_manager.py#L122-L142)):
```python
# ウィンドウをアクティブ化
try:
    target_window.activate()
except Exception as activate_error:
    logger.debug(f"activate() failed, trying alternative method: {activate_error}")
    try:
        import win32gui
        import win32con
        hwnd = win32gui.FindWindow(None, window_info.title)
        if hwnd:
            win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
            win32gui.SetForegroundWindow(hwnd)
    except Exception as win32_error:
        logger.warning(f"Alternative activation also failed: {win32_error}")
        # 失敗しても続行（ウィンドウは既に見つかっている）

time.sleep(0.3)
logger.info(f"Window activated successfully: {window_info.title}")  # ← 常に成功と報告
return True  # ← 常にTrueを返す
```

**問題点**:

1. **両方のアクティブ化方法が失敗してもエラーにならない**
   - `target_window.activate()` が失敗
   - 代替手段の `win32gui.SetForegroundWindow()` も失敗
   - しかし、コメント「失敗しても続行」により処理が継続される

2. **成功/失敗にかかわらず常に成功と報告**
   - ログに「Window activated successfully」と出力（141行目）
   - 常に `True` を返す（142行目）

3. **結果として間違ったウィンドウがスクリーンショット撮影される**
   - ウィンドウアクティブ化が失敗
   - その時点でアクティブだったウィンドウ（VSCode）のスクリーンショットが撮影される
   - しかし処理は成功として継続される

**なぜPage 2は正しく撮影されたか**:

Page 1の処理で以下が発生：
1. ウィンドウアクティブ化失敗（VSCodeがアクティブなまま）
2. VSCodeのスクリーンショット撮影 → `page_0001.png`
3. ページ送りコマンド（Right キー）送信
4. この時点でKindleウィンドウにフォーカスが移る（キー入力で自動的に）

Page 2の処理：
1. ウィンドウアクティブ化は失敗するが、すでにKindleがアクティブ
2. 正しいKindleウィンドウのスクリーンショット撮影 → `page_0002.png`

**影響範囲**:

- 初回スクリーンショット（page 1）が間違ったウィンドウを撮影する可能性が高い
- マルチモニター環境、他のアプリがフォーカスを持っている場合に問題が顕在化
- ログでは常に「成功」と報告されるため、デバッグが困難

**修正方針**:

1. **ウィンドウアクティブ化の成功を検証する**
   - `win32gui.GetForegroundWindow()` で実際にアクティブなウィンドウを確認
   - 期待するウィンドウハンドルと一致するか検証

2. **失敗時は明確にエラーを返す**
   - 両方のアクティブ化方法が失敗した場合は `False` を返す
   - 呼び出し側でエラーハンドリングを行う

3. **リトライロジックの追加**
   - 一定回数リトライしてからエラーとする
   - リトライ間隔を設ける

**修正コード案**:

```python
def activate_window(self, window_info: WindowInfo) -> bool:
    """指定されたウィンドウをアクティブ化する"""
    try:
        import win32gui
        import win32con

        # ウィンドウハンドルを取得
        hwnd = win32gui.FindWindow(None, window_info.title)
        if not hwnd:
            logger.error(f"Window handle not found: {window_info.title}")
            return False

        # 複数回リトライ
        max_retries = 3
        for attempt in range(max_retries):
            # 方法1: pygetwindow
            try:
                windows = gw.getWindowsWithTitle(window_info.title)
                if windows:
                    target_window = windows[0]
                    if target_window.isMinimized:
                        target_window.restore()
                        time.sleep(0.3)
                    target_window.activate()
            except Exception as e:
                logger.debug(f"pygetwindow activation failed (attempt {attempt+1}): {e}")

            # 方法2: win32gui (フォールバック)
            try:
                win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
                win32gui.SetForegroundWindow(hwnd)
            except Exception as e:
                logger.debug(f"win32gui activation failed (attempt {attempt+1}): {e}")

            time.sleep(0.3)

            # アクティブ化の検証
            current_hwnd = win32gui.GetForegroundWindow()
            if current_hwnd == hwnd:
                logger.info(f"Window activated successfully: {window_info.title}")
                return True

            logger.warning(f"Window activation verification failed (attempt {attempt+1}/{max_retries})")
            time.sleep(0.5)

        # すべてのリトライが失敗
        logger.error(f"Failed to activate window after {max_retries} attempts: {window_info.title}")
        return False

    except Exception as e:
        logger.error(f"Failed to activate window: {e}")
        return False
```

**実施した修正**:

修正を実装しました。

1. **[window_manager.py:94-155](src/capture/window_manager.py#L94-L155) の修正**:
   - リトライロジックを追加（最大3回）
   - `win32gui.GetForegroundWindow()` による検証を追加
   - 失敗時に明確に `False` を返すように修正
   - 成功時のみ `True` を返すように変更

2. **[main.py:215-217](main.py#L215-L217) の修正**:
   - `activate_window()` の戻り値をチェック
   - 失敗時はエラーログを出力して `False` を返す

3. **[main.py:253-255](main.py#L253-L255) の修正**:
   - ページ送り前の再アクティブ化でも戻り値をチェック
   - 失敗時は警告ログを出力（既にアクティブな可能性もあるためページ送りは継続）

**今後の対応**:

1. 実機でテストを実施（ユーザーによる動作確認が必要）
2. TROUBLESHOOTING.mdに「ウィンドウアクティブ化の失敗」として対処法を記載

---

### 今後の改善案

1. **統合テストの追加**: 実際のワークフロー全体をテストするテストケース
2. **エラーハンドリングの強化**: より詳細なエラーメッセージとリカバリー機能
3. **パフォーマンス最適化**: OCR処理の並列化、キャッシュの活用
4. **設定の検証**: 起動時に設定ファイルの妥当性をチェック
5. **ログの改善**: より分かりやすいログメッセージ、進捗表示の強化
6. **ウィンドウアクティブ化の信頼性向上**: リトライロジック、検証ロジックの実装
