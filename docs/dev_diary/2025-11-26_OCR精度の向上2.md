# 2025-11-26 OCR精度の向上 Phase 2

## 背景

Phase 1（二値化の無効化）により、OCR精度が大幅に向上しました（誤字率 15-20% → 3-5%）。
しかし、さらなる精度向上の余地があるため、追加の改善策を検討・実施します。

**現状の精度**: 誤字率 3-5%
**目標精度**: 誤字率 2-3%以下

## 精度向上の手法候補

### 1. スクリーンショット後の拡大 ⭐⭐⭐⭐⭐ 【採用】

**手法**: 撮影したスクリーンショットを補間技術で高解像度化

**期待効果**: 中〜高（誤字率 3-5% → 2-3%程度）

**実装方法**:
```python
from PIL import Image

# バイキュービック補間で2倍に拡大
image = image.resize((width * 2, height * 2), Image.BICUBIC)
# または LANCZOSリサンプリング（より高品質）
image = image.resize((width * 2, height * 2), Image.LANCZOS)
```

**メリット**:
- Kindleアプリの表示サイズを変える必要なし
- 文字が大きくなり、OCRエンジンが認識しやすくなる
- 実装が簡単
- 既存のワークフローに組み込みやすい

**デメリット**:
- メモリ使用量が増加（画素数が4倍）
- 処理時間が増加（約2-3倍）
- 補間によるアーティファクト（ぼやけ）の可能性

**設定パラメータ**:
```yaml
preprocessing:
  upscaling:
    enabled: true
    scale_factor: 2.0        # 拡大倍率（1.5, 2.0, 2.5など）
    interpolation: "lanczos" # lanczos, bicubic, bilinear
```

### 2. シャープ化処理の追加 ⭐⭐⭐⭐ 【採用】

**手法**: エッジを強調して文字をくっきりさせる

**期待効果**: 中（誤字率 3-5% → 2-4%程度）

**実装方法**:
```python
from PIL import ImageFilter

# アンシャープマスク
image = image.filter(ImageFilter.UnsharpMask(
    radius=2,      # ぼかしの半径
    percent=150,   # 強調の程度（100-200%）
    threshold=3    # 適用する最小輝度差
))
```

**メリット**:
- 文字のエッジが鮮明になる
- 処理が軽量
- 拡大と組み合わせることで相乗効果

**デメリット**:
- 過度な処理はノイズの強調につながる可能性
- パラメータの調整が必要

**設定パラメータ**:
```yaml
preprocessing:
  sharpening:
    enabled: true
    radius: 2         # ぼかしの半径
    percent: 150      # 強調の程度（100-200%）
    threshold: 3      # 適用する最小輝度差
```

### 3. コントラスト調整の強化 ⭐⭐⭐ 【検討中】

**現在の設定**: `clip_limit: 2.0`
**推奨設定**: `clip_limit: 3.0 - 4.0`

**期待効果**: 小〜中（誤字率 3-5% → 2.5-4%程度）

**実装**: 設定ファイルの変更のみで対応可能

**判断基準**: 拡大+シャープ化で十分な効果が得られなかった場合に実施

### 4. ノイズ除去の無効化 ⭐⭐ 【検討中】

**理由**: 画面キャプチャは既に高品質なため、ノイズ除去が逆効果の可能性

**期待効果**: 小（効果なし〜若干の改善）

**判断基準**: 他の手法で改善が見られない場合のみ試行

### 5. 複数解像度での解析＋マージ ⭐⭐ 【保留】

**手法**: 元画像と拡大画像の両方でOCRを実行し、信頼度の高い結果を採用

**期待効果**: 中〜高（誤字率 3-5% → 1-3%程度）

**デメリット**:
- 処理時間が2倍
- 実装が複雑
- メモリ使用量が大幅に増加

**判断基準**: 単一解像度での改善が限定的だった場合のみ検討

## 実施計画

### Phase 2.1: 画像の高解像度化 ✅ 実施

1. `ImageProcessor`に`upscale_image`メソッドを追加
2. 設定ファイルに`upscaling`セクションを追加
3. `optimize_for_ocr`パイプラインに組み込み（最初のステップとして）
4. テストケースを作成

**実装順序**:
```
1. ノイズ除去 → 削除（最初に実施）
2. 拡大処理    → 追加（新規）← ここで画像サイズを拡大
3. コントラスト調整
4. 傾き補正
5. 余白トリミング
6. 二値化（無効）
```

### Phase 2.2: シャープ化処理 ✅ 実施

1. `ImageProcessor`に`sharpen_image`メソッドを追加
2. 設定ファイルに`sharpening`セクションを追加
3. `optimize_for_ocr`パイプラインに組み込み（拡大の直後）
4. テストケースを作成

**実装順序**:
```
1. 拡大処理
2. シャープ化  → 追加（新規）← 拡大後の画像を鮮明化
3. コントラスト調整
4. 傾き補正
5. 余白トリミング
6. 二値化（無効）
```

### Phase 2.3: テストと評価 ✅ 実施

**テストコマンド**:
```bash
# 拡大+シャープ化を有効化してテスト
python main.py --title "LLM自作入門_enhanced" --total-pages 3 --debug
```

**評価指標**:
1. OCR精度（誤字率の測定）
2. 処理時間の増加（許容範囲: 2-3倍まで）
3. メモリ使用量（許容範囲: 4倍まで）
4. 画像品質（目視確認）

**比較対象**:
- Baseline: 二値化なし（Phase 1）
- Enhanced: 拡大+シャープ化（Phase 2）

## 実施記録

### 2025-11-26 午後

#### Step 1: upscale_imageメソッドの実装 ✅
- [x] ImageProcessorにメソッド追加
- [x] 設定ファイルにパラメータ追加
- [x] パイプラインに組み込み

**実装内容**:
- LANCZOS補間による2倍拡大を実装
- 1920x1057 → 3840x2114への高解像度化を確認
- 複数の補間方法（LANCZOS, BICUBIC, BILINEAR, NEAREST）をサポート

#### Step 2: sharpen_imageメソッドの実装 ✅
- [x] ImageProcessorにメソッド追加
- [x] 設定ファイルにパラメータ追加
- [x] パイプラインに組み込み

**実装内容**:
- UnsharpMaskフィルタによるシャープ化を実装
- radius=2.0, percent=150, threshold=3のパラメータを使用
- 拡大後の画像に対してエッジを強調

#### Step 3: テストと評価 ✅
- [x] テスト実行
- [x] 精度測定
- [x] 結果分析

## 参考情報

### 画像補間アルゴリズム

1. **NEAREST**: 最近傍補間（最速、品質最低）
2. **BILINEAR**: バイリニア補間（高速、品質中）
3. **BICUBIC**: バイキュービック補間（中速、品質高）
4. **LANCZOS**: Lanczosリサンプリング（低速、品質最高）← **推奨**

### アンシャープマスク

文字認識に最適なパラメータ:
- **radius**: 1-3（大きすぎるとハロー効果）
- **percent**: 120-180%（適度な強調）
- **threshold**: 2-5（ノイズの強調を防ぐ）

## 関連ファイル

- [src/preprocessor/image_processor.py](../../src/preprocessor/image_processor.py)
- [config/config.yaml](../../config/config.yaml)
- [main.py](../../main.py)

## テスト結果

### 実施コマンド
```bash
python main.py --title "LLM自作入門_enhanced" --total-pages 3 --debug
```

### パフォーマンス指標

**処理時間の変化**:
- Page 1: 17.73秒（OCR処理）
- Page 2: 56.48秒（OCR処理）
- Page 3: 47.01秒（OCR処理）
- **平均**: 約40秒/ページ（Phase 1の約2-3倍）

**メモリ使用量**:
- 画像サイズ: 1920x1057 → 3840x2114（4倍）
- 予想通りメモリ使用量が大幅に増加

### OCR精度の比較

#### Baseline（Phase 1: 二値化なし）の誤字例:
- 「大概模」→「大規模」
- 「キアル」→「モデル」
- 「Tarsimerアーキテクチャ」→「Transformerアーキテクチャ」
- 「★アル」→「モデル」
- 「LUなら」→「LLMなら」

#### Enhanced（Phase 2: 拡大+シャープ化）の誤字例:
- 「大衆模」→「大規模」
- 「radoreアーキラクチャ」→「Transformerアーキテクチャ」
- 「...Mを」→「LLMを」
- 「口コ」→「LLM」
- 「山M」→「LLM」

### 精度評価

**結果**: Phase 2の精度向上効果は限定的

**分析**:
1. **処理時間の大幅増加**: 2-3倍の処理時間がかかる
2. **メモリ使用量の増加**: 画像サイズが4倍になり、メモリ負荷が高い
3. **精度の改善**: わずかな改善はあるが、劇的な向上は見られない
   - Baseline: 誤字率 約3-5%
   - Enhanced: 誤字率 約3-5%（ほぼ変わらず）

**主な誤認識パターン**（両バージョン共通）:
- 「LLM」→「LUM」「LIM」「...M」「口コ」「山M」など
- 「Transformer」→「Tarnsimer」「radore」など
- 専門用語の誤認識が依然として存在

**考察**:
- 画面キャプチャは既に十分な品質があるため、拡大+シャープ化の効果は限定的
- Phase 1（二値化の無効化）で得られた改善（15-20% → 3-5%）が主要な改善
- さらなる精度向上には、より高度なアプローチが必要:
  1. Tesseractエンジンとの比較テスト
  2. Kindle表示倍率の向上（Kindleアプリ側での拡大）
  3. 商用OCR APIの使用（Google Cloud Vision等）
  4. OCRエンジンの調整（Yomitokuの設定変更）

## 結論

### 最終的な判断

**Phase 2（画像の高解像度化+シャープ化）は実用上推奨しない**

**理由**:
1. **コストパフォーマンスが悪い**: 処理時間が2-3倍になる割に精度向上は限定的
2. **メモリ負荷が高い**: 画像サイズが4倍になり、リソース消費が大きい
3. **精度改善が限定的**: Phase 1で既に大幅な改善を達成しており、追加の改善は微小

### 推奨設定（Phase 1のまま）

```yaml
preprocessing:
  upscaling:
    enabled: false  # 無効化を推奨
  sharpening:
    enabled: false  # 無効化を推奨
  binarization:
    enabled: false  # Phase 1で確立した最適設定
```

### 今後の改善案（Phase 2以降）

もしさらに精度を上げたい場合:

1. **Kindle表示倍率の向上** ⭐⭐⭐⭐
   - Kindleアプリ側で150%または200%表示に設定
   - スクリーンショット前に拡大することで、より高品質な入力を得る
   - 処理時間の増加なく、より大きな文字でOCR実行が可能

2. **Tesseractエンジンの比較テスト** ⭐⭐⭐
   - Yomitokuの代わりにTesseractを試す
   - 特に英語混じりのテキストでは精度が異なる可能性

3. **商用OCR APIの使用** ⭐⭐⭐⭐⭐
   - Google Cloud Vision API
   - Amazon Textract
   - Azure Computer Vision
   - コストはかかるが、ほぼ完璧な精度が期待できる

4. **複数解像度での解析+マージ** ⭐⭐
   - 元画像と拡大画像の両方でOCRを実行
   - 信頼度スコアに基づいて結果をマージ
   - 実装が複雑で処理時間が2倍

### 学んだこと

1. **全ての前処理が有効とは限らない**
   - 画面キャプチャは既に高品質なため、過度な処理は不要
   - Phase 1の二値化無効化が最も効果的だった

2. **コストと効果のバランスが重要**
   - 処理時間が2-3倍になる代償に見合う精度向上が得られなかった
   - 実用上は、Phase 1の設定で十分

3. **入力品質の改善が最も効果的**
   - OCR前の画像処理よりも、入力画像の品質（Kindle表示倍率）を上げる方が効果的
   - ソースデータの改善 > 後処理の改善

### 最終推奨

**Phase 1の設定（二値化なし、拡大なし、シャープ化なし）を維持することを推奨します。**

現状の誤字率3-5%は、多くの用途で十分実用的です。さらなる精度向上が必要な場合は、Kindle表示倍率の向上または商用OCR APIの使用を検討してください。
