# 2025-12-07: 最終ページの判定ロジック実装

## 背景

Kindleの文字サイズを大きくしてOCR精度を上げると、表示上のページ数と実際のページ数に乖離が生じる問題が発生。
実行開始時に正確なページ数の把握が困難なため、自動的に最終ページを検出する機能が必要。

## 実装方針

**方法1（多めのページ数指定）+ 方法3（ページ重複検出）の組み合わせ**

- 実際より多めのページ数（例: 500ページ）で開始
- 各ページのスクリーンショットを画像ハッシュで比較
- 連続して同じページが検出されたら最終ページと判断して自動停止
- 実際に処理したページ数を最後にレポート

## 実装の詳細

### 1. 画像類似度判定モジュールの作成

新規ファイル: `src/utils/image_similarity.py`

```python
"""
画像類似度判定モジュール

2つの画像が類似しているかを判定する機能を提供します。
"""

from PIL import Image
import imagehash
from typing import Optional


class ImageSimilarityChecker:
    """画像類似度を判定するクラス"""

    def __init__(self, hash_size: int = 16, similarity_threshold: int = 5):
        """
        初期化

        Args:
            hash_size: パーセプチュアルハッシュのサイズ（大きいほど精度が高い）
            similarity_threshold: 類似と判定するハミング距離の閾値（小さいほど厳密）
        """
        self.hash_size = hash_size
        self.similarity_threshold = similarity_threshold

    def calculate_hash(self, image: Image.Image) -> imagehash.ImageHash:
        """
        画像のパーセプチュアルハッシュを計算

        Args:
            image: PIL Image オブジェクト

        Returns:
            imagehash.ImageHash: 画像のハッシュ値
        """
        # 複数のハッシュアルゴリズムを組み合わせてより正確に
        # phash（パーセプチュアルハッシュ）を使用
        return imagehash.phash(image, hash_size=self.hash_size)

    def are_images_similar(
        self,
        image1: Image.Image,
        image2: Image.Image
    ) -> bool:
        """
        2つの画像が類似しているか判定

        Args:
            image1: 1つ目の画像
            image2: 2つ目の画像

        Returns:
            bool: 類似している場合はTrue
        """
        hash1 = self.calculate_hash(image1)
        hash2 = self.calculate_hash(image2)

        # ハミング距離を計算（異なるビット数）
        hamming_distance = hash1 - hash2

        # 閾値以下なら類似と判定
        return hamming_distance <= self.similarity_threshold

    def calculate_similarity_score(
        self,
        image1: Image.Image,
        image2: Image.Image
    ) -> float:
        """
        2つの画像の類似度スコアを計算（0.0-1.0）

        Args:
            image1: 1つ目の画像
            image2: 2つ目の画像

        Returns:
            float: 類似度スコア（1.0が完全一致、0.0が完全不一致）
        """
        hash1 = self.calculate_hash(image1)
        hash2 = self.calculate_hash(image2)

        hamming_distance = hash1 - hash2
        max_distance = self.hash_size ** 2  # 最大ハミング距離

        # スコアを0-1の範囲に正規化
        similarity = 1.0 - (hamming_distance / max_distance)
        return similarity
```

### 2. 最終ページ検出器の作成

新規ファイル: `src/utils/end_page_detector.py`

```python
"""
最終ページ検出モジュール

連続して同じページが検出されたら最終ページと判断します。
"""

from PIL import Image
from typing import Optional, List
from collections import deque
from loguru import logger

from .image_similarity import ImageSimilarityChecker


class EndPageDetector:
    """最終ページを検出するクラス"""

    def __init__(
        self,
        consecutive_same_pages: int = 3,
        similarity_threshold: int = 5
    ):
        """
        初期化

        Args:
            consecutive_same_pages: 連続して同じページと判定する回数
            similarity_threshold: 画像類似度の閾値
        """
        self.consecutive_same_pages = consecutive_same_pages
        self.similarity_checker = ImageSimilarityChecker(
            hash_size=16,
            similarity_threshold=similarity_threshold
        )

        # 最近のページ画像を保持するキュー（メモリ効率のため）
        self.recent_images: deque = deque(maxlen=consecutive_same_pages)
        self.same_page_count = 0

        logger.info(
            f"EndPageDetector initialized: "
            f"consecutive_same_pages={consecutive_same_pages}, "
            f"similarity_threshold={similarity_threshold}"
        )

    def check_page(self, image: Image.Image) -> bool:
        """
        ページをチェックして、最終ページに到達したか判定

        Args:
            image: チェックする画像

        Returns:
            bool: 最終ページに到達した場合はTrue
        """
        # 最初のページの場合
        if len(self.recent_images) == 0:
            self.recent_images.append(image.copy())
            self.same_page_count = 0
            return False

        # 直前のページと比較
        previous_image = self.recent_images[-1]
        is_similar = self.similarity_checker.are_images_similar(
            previous_image, image
        )

        if is_similar:
            # 同じページが続いている
            self.same_page_count += 1
            logger.debug(
                f"Same page detected: count={self.same_page_count}/"
                f"{self.consecutive_same_pages}"
            )

            # 規定回数連続で同じページなら最終ページと判定
            if self.same_page_count >= self.consecutive_same_pages:
                logger.info(
                    f"End page detected: {self.consecutive_same_pages} "
                    f"consecutive same pages found"
                )
                return True
        else:
            # 異なるページ：カウントをリセット
            self.same_page_count = 0
            self.recent_images.append(image.copy())

        return False

    def reset(self):
        """検出器の状態をリセット"""
        self.recent_images.clear()
        self.same_page_count = 0
        logger.debug("EndPageDetector reset")

    def get_similarity_score(self, image: Image.Image) -> Optional[float]:
        """
        直前のページとの類似度スコアを取得

        Args:
            image: チェックする画像

        Returns:
            float: 類似度スコア（0.0-1.0）。直前のページがない場合はNone
        """
        if len(self.recent_images) == 0:
            return None

        previous_image = self.recent_images[-1]
        return self.similarity_checker.calculate_similarity_score(
            previous_image, image
        )
```

### 3. main.py への統合

#### 3.1 インポート追加

```python
from src.utils.end_page_detector import EndPageDetector
```

#### 3.2 KindleOCRWorkflow クラスの初期化に追加

```python
def __init__(self, config: dict):
    # ... 既存のコード ...
    self.window_maximized = False

    # 最終ページ検出器を追加
    self.end_page_detector = None
```

#### 3.3 initialize メソッドで検出器を初期化

```python
def initialize(self, book_title: str, total_pages: int, start_page: int = 1):
    # ... 既存の初期化コード ...

    # 最終ページ検出器を初期化
    self.end_page_detector = EndPageDetector(
        consecutive_same_pages=self.config["detection"].get(
            "consecutive_same_pages", 3
        ),
        similarity_threshold=self.config["detection"].get(
            "similarity_threshold", 5
        )
    )

    logger.info("Workflow initialized successfully")
    return True
```

#### 3.4 process_page メソッドで最終ページをチェック

```python
def process_page(self, page_number: int) -> dict:
    """
    1ページを処理

    Returns:
        dict: 処理結果
            - success: bool - 処理成功
            - is_end_page: bool - 最終ページに到達したか
    """
    try:
        logger.info(f"Processing page {page_number}/{self.state.total_pages}")

        # ... ウィンドウ検出・アクティブ化・スクリーンショット撮影 ...

        # 最終ページチェック（スクリーンショット撮影後）
        is_end_page = self.end_page_detector.check_page(image)

        if is_end_page:
            logger.warning(
                f"End page detected at page {page_number}. "
                f"The same page appeared {self.end_page_detector.consecutive_same_pages} "
                f"times consecutively."
            )
            # 最終ページの情報をログに記録
            similarity_score = self.end_page_detector.get_similarity_score(image)
            if similarity_score:
                logger.info(f"Similarity score with previous page: {similarity_score:.2%}")

        # ... OCR処理とテキスト保存 ...

        logger.info(f"Page {page_number} processed successfully")
        return {
            "success": True,
            "is_end_page": is_end_page
        }

    except Exception as e:
        logger.error(f"Failed to process page {page_number}: {e}")
        return {
            "success": False,
            "is_end_page": False
        }
```

#### 3.5 run メソッドで最終ページ検出時に停止

```python
def run(self) -> bool:
    try:
        # ... 既存のコード ...

        # メインループ
        for page in range(start_page, self.state.total_pages + 1):
            # ページ処理
            result = self.process_page(page)

            if result["success"]:
                # 成功時
                consecutive_failures = 0
                self.progress_tracker.update_progress(page, failed=False)
                self.state.processed_pages.append(page)
                self.state.current_page = page

                # 最終ページ検出時は処理を終了
                if result["is_end_page"]:
                    logger.info(
                        f"Stopping at page {page} (end page detected). "
                        f"Actual total pages: {page}"
                    )
                    self.state.total_pages = page  # 実際のページ数を更新
                    break
            else:
                # 失敗時の処理...

        # ... 残りのコード ...
```

### 4. 設定ファイルへの追加

`config/config.yaml` に以下を追加:

```yaml
# 最終ページ検出設定
detection:
  # 連続して同じページと判定する回数（3回推奨）
  consecutive_same_pages: 3

  # 画像類似度の閾値（ハミング距離）
  # 小さいほど厳密に判定（5推奨、0-20の範囲）
  similarity_threshold: 5
```

### 5. 必要なパッケージの追加

`requirements.txt` に以下を追加:

```
imagehash>=4.3.1
```

インストール:

```bash
./venv/Scripts/python.exe -m pip install imagehash
```

## 使用方法

### 従来の方法（正確なページ数がわかる場合）

```bash
python main.py --title "書籍名" --total-pages 150
```

### 新しい方法（ページ数が不明な場合）

**多めのページ数を指定** - 自動的に最終ページで停止します:

```bash
python main.py --title "書籍名" --total-pages 500
```

実行中のログ例:

```
[INFO] Processing page 145/500
[DEBUG] Same page detected: count=1/3
[INFO] Processing page 146/500
[DEBUG] Same page detected: count=2/3
[INFO] Processing page 147/500
[DEBUG] Same page detected: count=3/3
[INFO] End page detected: 3 consecutive same pages found
[INFO] Stopping at page 147 (end page detected). Actual total pages: 147
[INFO] Processing completed!
[INFO] Total pages: 147
[INFO] Processed pages: 147
```

## 仕組みの詳細

### パーセプチュアルハッシュ（pHash）

- 画像の視覚的な特徴を数値化
- わずかな違い（圧縮、明るさ調整など）に強い
- ハミング距離で類似度を測定

### 最終ページの判定ロジック

1. **各ページのスクリーンショット撮影後**に画像ハッシュを計算
2. **直前のページとハミング距離を比較**
3. 類似度が閾値以下なら「同じページ」とカウント
4. **連続3回**同じページなら最終ページと判定
5. 処理を自動停止し、実際のページ数を記録

### なぜ3回連続なのか？

- **1回だけ**: 誤検出のリスクが高い（たまたま似たページがある可能性）
- **2回連続**: やや信頼性が低い
- **3回連続**: 最終ページに到達していることがほぼ確実
- **4回以上**: 無駄なページ送りが増える

## メリット

1. **正確なページ数が不要** - 大きめの数値（500など）を指定すればOK
2. **自動停止** - 最終ページで自動的に停止するため、無駄な処理がない
3. **柔軟な対応** - 文字サイズを変更してもページ数を気にする必要がない
4. **実際のページ数を記録** - 最終的に何ページ処理したかが正確にわかる

## 注意点

1. **初回は多めのページ数を指定**すること（実際より少ないと途中で終わってしまう）
2. **類似度閾値の調整**が必要な場合がある（デフォルト5で多くのケースに対応）
3. **メモリ効率**: 最近3枚の画像のみをメモリに保持（dequeを使用）

## 今後の拡張案

1. **空白ページ検出**: 完全に白いページを検出して自動スキップ
2. **目次/索引ページの自動検出**: 特定のパターンを持つページを識別
3. **ページ番号のOCR**: 画面下部のページ番号をOCRで読み取って実際のページ数を把握
